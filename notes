This  Is How To See How This App Works In  A Synchronous Way! part 1



Provider: any component that we wrap in provider will have access to our redux Store 
applyMiddleware(thunk) : thunk is Middleware that we are using we have to incorparate with Devtools authomatically SET UP
so we dont have our application connected to the Devtools 

What we need to incorparate so that we can pass more than one middle ware as the second argument here?
so we pass compose here which comes from redux 

import {createStore, applyMiddleware, compose} from 'redux'

so what is compose do ?
compose combines a couple diffrent Middleware into one so we can just pass one argument here what thought this is 
create store looking for. when we typically use compose we typically set up a Const alot of times called enchancer 
we are enchancing our store as a function they are built in they come with redux so create store we are passing arguments by
Middleware we are passing arguments so we want use composed smiliar way.


const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
if window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ exist it going to be that if it doesnt excist 
we want to be compose

let store = createStore(reducer, composeEnchancers(applyMiddleware(thunk)))


we must call store in provider what ever we call in our variable let store ={store}


ReactDOM.render(
  <Provider store={store}>
   <App />
  </Provider>,
  
  document.getElementById('root')
);

Container Components: parent component Usually they are class Components usually what they do they render other components 
they kind of whhat you want to contain a bunch of other components that they contain be other containers  or presentaional components
when you see containers components they are just components 
player container job probably would be get data from our store and render other components we will have to do with the players
and also handle some of the pass down data to those child components and handle some of the data whether do did it now or functions 
and contractcontainer can also do the smiliar thing maybe not render all the contract but render some od the top level 
component and other contract components will render more more children 

container components is that handle some of components  some of passing quick functions and sending things up to store 


REDUCER (playerReducer.js): An Action dispatching to  our  reducer  which means sending an action object to our reducer and our reducer
is responsible for taking in that action object and decides based on the way you set up reducer it'll have those condition 
in there decides what we want update about our current store reducer will return a new version of that store
each time we update something in our store this is the reducer thats going to be returning that new updated state 
the reason why we have to pass reducer in the create store as argument we are saying 
this is the our store anytime something is dispatched anytime we see dispatch we want that action object to be an action object to be
send to this reducer which will update this store(value of the store)

why we are using thunk in first place 
its returns a function from action creater (fetchPlayer.js)
what is the benefit for us? 
we can use it other places easily.



example reducer 
let store = createStore(playerReducer, composeEnchancers(applyMiddleware(thunk)))

dispatch(actionObject)


export default function playerReducer(state = {players: []}, action ) {

return state 



}


ACTION Creater(fetchPlayer.js) = this is a function like reducer this is where we are fetching our players
what we return from this function or dispatch is an action object  or just an action 
example 
dispatch(actionObject)
the diffrence is an action creaters creates and object then that action object will dispatch to our reducer(playerReducer.js)
Which will return our new version of our state based on the action that we sent.

Action creator typically before you incorparate a fetch request or any sort of async request return  just regular JabaScript objects that
that have a {type: 'aaaa', payload} when the action creator return something like this our fetchPlayer automatically dispatches whatever 
what ever that action to our reducer for us. Since this fetch request takes sometime we cant return action rightaway and 
we dont want our connect function to automatically call dispatch for us in (fetchPlayers.js) instead we want to use this fetch inside
our action so we can call dispatch once we've gotten that in thunk allows us to use dispatch inside of here (fetchPlayer.js) 
without thunk we can not use dispatch inside an action creator. What are we need to set up in here that we can use this patch in dispatch 
instead of logging it? We have to return dispatch 
                                              |
Chapter-1                                     |
                                              |
 export function fetchPlayers() {             |
  return (dispatch) => {<---------------------|------>  instead of connect automatically dispatching an action with thunk 
                                                          we are allowed to pass have function which is all function here 
 fetch ('http://localhost:3000/players')                  we are passing in dispatch built in dispatch function as an argument 
  .then(response => response.json())                      so that we can use it inside of our action creator and dispatch 
  .then(players => dispatch ({                            the response from our fetch
   type: 'FETCH_ACCOUNTS',
   payload: players
  }))                     

.then(response => response.json()) <--------- we will get some response eventually once promise resolved 
                                              response from our request comes into this first .then we converts
                                              that response into JSON when the response converted the json 
  .then(players   => dispatch({    <----------response camedown in as the argument in second .then 
                                              We can call this what ever we want they are just arguments in function 
                                              players is the same as this converted response into JSON WE then dispatching 
                                              Which is saying going to our reducer 
 |--->type: 'FETCH_ACCOUNTS',<------------------take our reducer this action object just an object take that and update our Redux store based
 |                                            on the information that  sending you here. so this is dispatching to our reducer
 |                                           with a type: 'FETCH_ACCOUNTS' and payload: players
 |
 |   payload: players                                            
 |
 |   }
 |
 | }
 |
 |   chapter 2/  playerReducer.js
 |
 |     so what we have to do with our reducer all its doing returning this initial state, i want my reducer  yo be everytime we dispatch
 |     an action i wanted to update the state based on that action so what we need to do and you know we need set up switch statement 
 |
 |   export default function playerReducer(state = {players: []}, action ) { <--------------------------|                        
 |   debugger;                                                                                          |
 |     switch (action.type){                                                                            |
 |------>case 'FETCH_PLAYERS':--->first case we are checkin our switch to type:'FETCH_ACCOUNTS(line 113)|of this action whole thing coming to our reducer
      return state ---------------> if this the action type fetch players we want to return state       |          
     default:                   before we fethcing anything at first our state is just initially this object with keys players: [] poiting to empty array  
                                the goal is after that fetch request and after we com einto this players|state that looks that its an object 
                                based on switch and action that is coming in from empty object  how do I|achieve them with the players 
                                pointing to an array of players                                         |     
         return state                                                                                   |
    }                                                                                                   |    
                                                                                                        |
}                                                                                                       |
                                                                                                        |
                                                                                                        |
chapter 3/ playerReducer.js                                                                             |
                                                                                                        |
export default function playerReducer(state = {players: []}, action ) {                                 |
debugger;                                                                                               |
    switch (action.type){                                                                               |
     case 'FETCH_PLAYERS':                                                                              |
     return {players: action.payload}<-We want to return an object which the key players points to an array. we are saying  
     default:                           return an object remember what ever we returned from our reducer is our new our REDUX STATE
         return state                   this will be our state that we access in any other component that we access its returning 
                                        a new version  of state so what we're saying right now is no longer want players point to 
                                        an empty array i wanted to point to the array that cameback from my fetch request 
    }

}


before we create our action creater and send to data to reducer we needs in order to have access to our reducer to update our store 
in index.js we wrapped our app in a  provider to gives any components(or child or shcild of child components) access to our store

we need another piece that specific component can have access to  store. So we need to import connect 
App.js
import {connect} from 'react-redux'
....


                                                        ** mapStateToProps **
mapStateToPops = {state} => {    
    return {                                ** I want to access to this particular part of the store **
        players: state.players    <--------- mapStateToProps is our way of accessing our stores values in our store as props                                 
                                            then give us access to something if we set this up we could then inside of our app
                                            component call this.props.players we have to  set up in mapStateProps as following
                                            to give us access to see what is already in our store
                                           
    }  
}



export default connect(null,{fetchPlayers})(App);
 this connect actually calling dispatch({}) for us  on the return value of fetch accounts for us. 
if we dont pass (mapStateToPops) Here nothings gonan happen. This is saying We passed this function the return value of This
is coming from our store, you can pass mapDispatch props or action creater as a second argument gives us ability to update 
our store directly from this component. so this is the formula access to this.props.fetchplayers through props to something pulled into 
 function fetchPlayers which will then update our store.  (mapStateToProps) is give us  access to what is the currently in the store 
 action (fetchPlayers) or (mapStateToPops) as a second argument gives us to ability to dispatch new action or update to our store
 directly from our component. 



App.js 

import React from 'react';
import {connect} from 'react-redux'
import {fetchPlayers}from './actions/fetchPlayers'
class App extends React.Component {
 
  componentDidMount (){  **Our App component mounted **
   this.props.fetchPlayers({type:'FETCH_PLAYERS', payload: {name:'Checking' }})
   What is happening and knew that this return action should send to reducer 

  
   **this.props.fetchPlayers called  we passed in this action object -> ({type:'FETCH_PLAYERS', payload: {name:'Checking' }}
    then this action return this action object  how we end up hitting this debugger in our reducer ?
  What is happening and knew that this    | return action should send to the reducer(playerReducer.js) we never invoked Our                                        
   FetchPlayer.js                         | playerReducer function what did that for us?   
                                          | reducer acception action in index.js file const store = createStore(playerReducer, composeEnchancers(applyMiddleware(thunk)))
    export function fetchPlayers(action){ | telling that thats | is the rediucer is teh playerReducer but really happening                   
    return action    <--------------------|-> when its return  | that it went into  the playerReducer. What we earned that function                    
 
 that sends an action  object to  reducer. the reason its      |  expecting add once that something returned from there.                       |
 then its then fire our connect                                |
 export default connect(null,{fetchPlayers})(App);             |
dispatch to our store store.dispatch({type: 'FETCH_PLAYERS',   |   payload: {name: 'Checking'}})                                                              |
then this is therefore sent into our reducer(playerReducer.js) | as a action! you dont see dispatch because its automatically happen
playerReducer.js                                               v
export default function playerReducer(state = {players: []}, action ) {

                                                    the reason we need THUNK is when we mant to make a synchronous request 
                                                    Which is fetch request in fetch player.js            
                                                          
}
 }


  render() {
    return (
      <div className="App">
        App
      </div>
    );
  }
}

// const mapStateToProps = (state) => {
// return {
//   players: state.players
// }
// }

export default connect(null,{fetchPlayers})(App);
-----------------------------------------------------------------------------------------------------------------------------------

Part 2

Containers/PlayerContainers.js

someone to be able to creat players and then a view list of players and maybe edit players and contract 
// something that we wnt to contained with this players.

container what it should really do is render othee conponents pass them data if they require data and they also can have 
other functions inside of them callback functions or anything like that component did hope to get there unders that helps 
its more to pass it to appropriate that will render it an will handle changes thorugh a form and so on..

they typcially are a class component a lot of times they may need state is that component did about function to be which we get with
a class component. Container components are one of our top-level container components going to wonder what to render inside to our 
app component. We will render these coponents that we have (Players.js - PlayerInput.js)
Remember Capitalization does matter. Components you have to capitalized  and matching the name of the component when you have action or
reducer they are typically camel case we want to render both components inside the playerContainer so first thing you need to do 
imported connect.                   |
                                                                 |
import React from 'react';                                       |
                                                                 |
import Players from '../components/Players'   <------------------|
import PlayerInput from '../components/PlayerInput' <----------- |

class PlayerContainer extends React.Component{-> which is accessing this components from react library 
    
}

export default connect()(PlayersContainer) hen we want to use connect

we render Player container in our app.js. We remember this an application that is using redux if we want to fetch our players 
from our backend to add them in our redux store to use those players from our backend how will we use what will want to our 
players container how we gonna get  those player and how will we pass them to this players component?

Answer ; we need to import connect 

App.js 
import React from 'react';

import {connect} from 'react-redux'
*import PlayerContainer from './containers/PlayersContainer'*** we must import Player components we still our app 
                                                                 render in the Dom at index.js ****

import React from 'react';
import Players from '../components/Players'
import {connect} from 'react-redux'
import {fetchPlayers} from '../actions/fetchPlayers'
import PlayerInput from '../components/PlayerInput'


class PlayerContainer extends React.Component{
  
    componentDidMount(){
//   this.props.fetchPlayers()


    }

    render () {
      return (
      <div> 
      
        <PlayerInput/>
        <Players players={this.props.players}/> <----| we need to send  players to our players. We are sending and accessing players 
                                                     |   with  {this.props.players}
                                                     |
      </div>                                         |
                                                     |
      )                                              |
    }                                                |
                                                     |-------------------------------------------------------------------| 
}                                                                                                                        |
                                                            ****NOT***                                                   |    
 const mapStateToProps = state => { <----------  {fetchPlayers} equivalent to mapDispatchtoProps                         |
     return{                                  |   getting players for our REDUX STORE accessing them                     |
         players: state.players <-------------|-->through props inside this component then sending those players to our players component
     }                                        |    remember we set up our players.js component to receive props 
 }                                            |
                                              |
                                              |
export default connect(mapStateToProps, {fetchPlayers})(PlayerContainer)
                            

COMPONENTS 


PlayerInput.js Component
 We want to create a new form to create a new Player also our index.js shows all our Players that why we need
 playerInput component to create. In order to have controlled form you need control those values in you can have a local state 
 that controls that values, its makes simpler but you also could everytime there was a change to the form you could send that to your 
 Redux Store . its makes more sense of it as a class component that local state holding to form values
 
 
 
 import React from 'react'

class PlayerInput extends React.Component {

    render() {
     return (
       <div>
    
        PlayerInput 


       </div>



     )

    }


}

export default PlayerInput












 PlayerList.js Component 

 we would we want for a lid that would become a list of all of our players 




   Functional Component / Players.js 

you could have choose to have this as a class component as far as the requirements are concerned you need five 
functional components so this could be a good one to use if you had five others without having something like this as a 
function component then that works to but this is absolutely works. We have to set up functional components like regular 
function personally i liek arrow function. This component will be responsible for rendering a list of players this is what wee need
and how this is component going to get those players. With calss component we just call this.props, with the functional component 
We have to pass props as an argument->  const Players = (props) => { 
We can also use destructive to pass in with the actual name ->  const Players = ({players}) => {






import React from 'react'

 const Players = (props) => { remember we set up our players component to receive props 


****we can accees anything we pass it thorugh props we dont need render inside the functional component we just need return 
functional components they are just  functions ****
return (
   <div> 
 
    Players 
 
   </div>


  )

 }

 export default Players

 summary: We are attaching app to DOM which is rendering our players container which is not rendering anything itself
 aside from these two other containers 


Phase 2 players.js 

import React from 'react'

 const Players = (props) => {
 console.log(props)
  return (
   <div>                             
                                     evertime you iterate its gonna want you put a key into the html element holding that iteration
    {props.players.map(player=> <li> key={player.id} {player.name} - {player.height}-{player.weight}-{player.position}-{player.points}</li>)}
                   we have to iterate over each player  and have a list to have return here  
                   we are creating a list with<li> list of our players on this element tags we need JSX because this is coming as 
                   JavaScript since we are inside of html element we have to access the values of these props that we are passing in 
   </div>                


  )

 }

 export default Players