Provider: any component that we wrap in provider will have access to our redux Store 
applyMiddleware(thunk) : thunk is Middleware that we are using we have to incorparate with Devtools authomatically SET UP
so we dont have our application connected to the Devtools 

What we need to incorparate so that we can pass more than one middle ware as the second argument here?
so we pass compose here which comes from redux 

import {createStore, applyMiddleware, compose} from 'redux'

so what is compose do ?
compose combines a couple diffrent Middleware into one so we can just pass one argument here what thought this is 
create store looking for. when we typically use compose we typically set up a Const alot of times called enchancer 
we are enchancing our store as a function they are built in they come with redux so create store we are passing arguments by
Middleware we are passing arguments so we want use composed smiliar way.


const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
if window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ exist it going to be that if it doesnt excist 
we want to be compose

let store = createStore(reducer, composeEnchancers(applyMiddleware(thunk)))


we must call store in provider what ever we call in our variable let store ={store}


ReactDOM.render(
  <Provider store={store}>
   <App />
  </Provider>,
  
  document.getElementById('root')
);

Container Components: parent component Usually they are class Components usually what they do they render other components 
they kind of whhat you want to contain a bunch of other components that they contain be other containers  or presentaional components
when you see containers components they are just components 
player container job probably would be get data from our store and render other components we will have to do with the players
and also handle some of the pass down data to those child components and handle some of the data whether do did it now or functions 
and contractcontainer can also do the smiliar thing maybe not render all the contract but render some od the top level 
component and other contract components will render more more children 

container components is that handle some of components  some of passing quick functions and sending things up to store 


REDUCER (playerReducer.js): An Action dispatching to  our  reducer  which means sending an action object to our reducer and our reducer
is responsible for taking in that action object and decides based on the way you set up reducer it'll have those condition 
in there decides what we want update about our current store reducer will return a new version of that store
each time we update something in our store this is the reducer thats going to be returning that new updated state 
the reason why we have to pass reducer in the create store as argument we are saying 
this is the our store anytime something is dispatched anytime we see dispatch we want that action object to be an action object to be
send to this reducer which will update this store(value of the store)

why we are using thunk in first place 
its returns a function from action creater (fetchPlayer.js)
what is the benefit for us? 
we can use it other places easily.



example reducer 
let store = createStore(playerReducer, composeEnchancers(applyMiddleware(thunk)))

dispatch(actionObject)


export default function playerReducer(state = {players: []}, action ) {

return state 



}


ACTION Creater(fetchPlayer.js) = this is a function like reducer this is where we are fetching our players
what we return from this function or dispatch is an action object  or just an action 
example 
dispatch(actionObject)
the diffrence is an action creaters creates and object then that action object will dispatch to our reducer(playerReducer.js)
Which will return our new version of our state based on the action that we sent

before we create our action creater and send to data to reducer we needs in order to have access to our reducer to update our store 
in index.js we wrapped our app in a  provider to gives any components(or child or shcild of child components) access to our store

we need another piece that specific component can have access to  store. So we need to import connect 
App.js
import {connect} from 'react-redux'
....


                                                        ** mapStateToProps **
mapStateToPops = {state} => {    
    return {                                ** I want to access to this particular part of the store **
        players: state.players    <--------- mapStateToProps is our way of accessing our stores values in our store as props                                 
                                            then give us access to something if we set this up we could then inside of our app
                                            component call this.props.players we have to  set up in mapStateProps as following
                                            to give us access to see what is already in our store
                                           
    }  
}



export default connect(null,{fetchPlayers})(App);
 this connect actually calling dispatch({}) for us  on the return value of fetch accounts for us. 
if we dont pass (mapStateToPops) Here nothings gonan happen. This is saying We passed this function the return value of This
is coming from our store, you can pass mapDispatch props or action creater as a second argument gives us ability to update 
our store directly from this component. so this is the formula access to this.props.fetchplayers through props to something pulled into 
 function fetchPlayers which will then update our store.  (mapStateToProps) is give us  access to what is the currently in the store 
 action (fetchPlayers) or (mapStateToPops) as a second argument gives us to ability to dispatch new action or update to our store
 directly from our component. 



App.js 

import React from 'react';
import {connect} from 'react-redux'
import {fetchPlayers}from './actions/fetchPlayers'
class App extends React.Component {
 
  componentDidMount (){  **Our App component mounted **
   this.props.fetchPlayers({type:'FETCH_PLAYERS', payload: {name:'Checking' }})
   What is happening and knew that this return action should send to reducer 

  
   **this.props.fetchPlayers called  we passed in this action object -> ({type:'FETCH_PLAYERS', payload: {name:'Checking' }}
    then this action return this action object  how we end up hitting this debugger in our reducer ?
  What is happening and knew that this    | return action should send to the reducer(playerReducer.js) we never invoked Our                                        
   FetchPlayer.js                         | playerReducer function what did that for us?   
                                          | reducer acception action in index.js file const store = createStore(playerReducer, composeEnchancers(applyMiddleware(thunk)))
    export function fetchPlayers(action){ | telling that thats | is the rediucer is teh playerReducer but really happening                   
    return action    <--------------------|-> when its return  | that it went into  the playerReducer. What we earned that function                    
 
 that sends an action  object to  reducer. the reason its      |  expecting add once that something returned from there.                       |
 then its then fire our connect                                |
 export default connect(null,{fetchPlayers})(App);             |
dispatch to our store store.dispatch({type: 'FETCH_PLAYERS',   |   payload: {name: 'Checking'}})                                                              |
then this is therefore sent into our reducer(playerReducer.js) | as a action! you dont see dispatch because its automatically happen
playerReducer.js                                               v
export default function playerReducer(state = {players: []}, action ) {

                                                    the reason we need THUNK is when we mant to make a synchronous request 
                                                    Which is fetch request in fetch player.js            
                                                          
}
 }


  render() {
    return (
      <div className="App">
        App
      </div>
    );
  }
}

// const mapStateToProps = (state) => {
// return {
//   players: state.players
// }
// }

export default connect(null,{fetchPlayers})(App);

