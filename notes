This  Is How To See How This App Works In  A Synchronous Way! part 1



Provider: any component that we wrap in provider will have access to our redux Store 
applyMiddleware(thunk) : thunk is Middleware that we are using we have to incorparate with Devtools authomatically SET UP
so we dont have our application connected to the Devtools 

What we need to incorparate so that we can pass more than one middle ware as the second argument here?
so we pass compose here which comes from redux 

import {createStore, applyMiddleware, compose} from 'redux'

so what is compose do ?
compose combines a couple diffrent Middleware into one so we can just pass one argument here what thought this is 
create store looking for. when we typically use compose we typically set up a Const alot of times called enchancer 
we are enchancing our store as a function they are built in they come with redux so create store we are passing arguments by
Middleware we are passing arguments so we want use composed smiliar way.


const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
if window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ exist it going to be that if it doesnt excist 
we want to be compose

let store = createStore(reducer, composeEnchancers(applyMiddleware(thunk)))


we must call store in provider what ever we call in our variable let store ={store}


ReactDOM.render(
  <Provider store={store}>
   <App />
  </Provider>,
  
  document.getElementById('root')
);

Container Components: parent component Usually they are class Components usually what they do they render other components 
they kind of whhat you want to contain a bunch of other components that they contain be other containers  or presentaional components
when you see containers components they are just components 
player container job probably would be get data from our store and render other components we will have to do with the players
and also handle some of the pass down data to those child components and handle some of the data whether do did it now or functions 
and contractcontainer can also do the smiliar thing maybe not render all the contract but render some od the top level 
component and other contract components will render more more children 

container components is that handle some of components  some of passing quick functions and sending things up to store 


REDUCER (playerReducer.js): An Action dispatching to  our  reducer  which means sending an action object to our reducer and our reducer
is responsible for taking in that action object and decides based on the way you set up reducer it'll have those condition 
in there decides what we want update about our current store reducer will return a new version of that store
each time we update something in our store this is the reducer thats going to be returning that new updated state 
the reason why we have to pass reducer in the create store as argument we are saying 
this is the our store anytime something is dispatched anytime we see dispatch we want that action object to be an action object to be
send to this reducer which will update this store(value of the store)

why we are using thunk in first place 
its returns a function from action creater (fetchPlayer.js)
what is the benefit for us? 
we can use it other places easily.



example reducer 
let store = createStore(playerReducer, composeEnchancers(applyMiddleware(thunk)))

dispatch(actionObject)


export default function playerReducer(state = {players: []}, action ) {

return state 



}


ACTION Creater(fetchPlayer.js) = this is a function like reducer this is where we are fetching our players
what we return from this function or dispatch is an action object  or just an action 
example 
dispatch(actionObject)
the diffrence is an action creaters creates and object then that action object will dispatch to our reducer(playerReducer.js)
Which will return our new version of our state based on the action that we sent.

Action creator typically before you incorparate a fetch request or any sort of async request return  just regular JabaScript objects that
that have a {type: 'aaaa', payload} when the action creator return something like this our fetchPlayer automatically dispatches whatever 
what ever that action to our reducer for us. Since this fetch request takes sometime we cant return action rightaway and 
we dont want our connect function to automatically call dispatch for us in (fetchPlayers.js) instead we want to use this fetch inside
our action so we can call dispatch once we've gotten that in thunk allows us to use dispatch inside of here (fetchPlayer.js) 
without thunk we can not use dispatch inside an action creator. What are we need to set up in here that we can use this patch in dispatch 
instead of logging it? We have to return dispatch 
                                              |
Chapter-1                                     |
                                              |
 export function fetchPlayers() {             |
  return (dispatch) => {<---------------------|------>  instead of connect automatically dispatching an action with thunk 
                                                          we are allowed to pass have function which is all function here 
 fetch ('http://localhost:3000/players')                  we are passing in dispatch built in dispatch function as an argument 
  .then(response => response.json())                      so that we can use it inside of our action creator and dispatch 
  .then(players => dispatch ({                            the response from our fetch
   type: 'FETCH_ACCOUNTS',
   payload: players
  }))                     

.then(response => response.json()) <--------- we will get some response eventually once promise resolved 
                                              response from our request comes into this first .then we converts
                                              that response into JSON when the response converted the json 
  .then(players   => dispatch({    <----------response camedown in as the argument in second .then 
                                              We can call this what ever we want they are just arguments in function 
                                              players is the same as this converted response into JSON WE then dispatching 
                                              Which is saying going to our reducer 
 |--->type: 'FETCH_ACCOUNTS',<------------------take our reducer this action object just an object take that and update our Redux store based
 |                                            on the information that  sending you here. so this is dispatching to our reducer
 |                                           with a type: 'FETCH_ACCOUNTS' and payload: players
 |
 |   payload: players                                            
 |
 |   }
 |
 | }
 |
 |   chapter 2/  playerReducer.js
 |
 |     so what we have to do with our reducer all its doing returning this initial state, i want my reducer  yo be everytime we dispatch
 |     an action i wanted to update the state based on that action so what we need to do and you know we need set up switch statement 
 |
 |   export default function playerReducer(state = {players: []}, action ) { <--------------------------|                        
 |   debugger;                                                                                          |
 |     switch (action.type){                                                                            |
 |------>case 'FETCH_PLAYERS':--->first case we are checkin our switch to type:'FETCH_ACCOUNTS(line 113)|of this action whole thing coming to our reducer
      return state ---------------> if this the action type fetch players we want to return state       |          
     default:                   before we fethcing anything at first our state is just initially this object with keys players: [] poiting to empty array  
                                the goal is after that fetch request and after we com einto this players|state that looks that its an object 
                                based on switch and action that is coming in from empty object  how do I|achieve them with the players 
                                pointing to an array of players                                         |     
         return state                                                                                   |
    }                                                                                                   |    
                                                                                                        |
}                                                                                                       |
                                                                                                        |
                                                                                                        |
chapter 3/ playerReducer.js                                                                             |
                                                                                                        |
export default function playerReducer(state = {players: []}, action ) {                                 |
debugger;                                                                                               |
    switch (action.type){                                                                               |
     case 'FETCH_PLAYERS':                                                                              |
     return {players: action.payload}<-We want to return an object which the key players points to an array. we are saying  
     default:                           return an object remember what ever we returned from our reducer is our new our REDUX STATE
         return state                   this will be our state that we access in any other component that we access its returning 
                                        a new version  of state so what we're saying right now is no longer want players point to 
                                        an empty array i wanted to point to the array that cameback from my fetch request 
    }

}


before we create our action creater and send to data to reducer we needs in order to have access to our reducer to update our store 
in index.js we wrapped our app in a  provider to gives any components(or child or shcild of child components) access to our store

we need another piece that specific component can have access to  store. So we need to import connect 
App.js
import {connect} from 'react-redux'
....




PlayerReducer.js phase 2 

export default function playerReducer(state = {players: []}, action ) {  problems coming from here 
    switch (action.type){
      case 'FETCH_PLAYERS':                                          // we just have fetch request 
        return {players: action.payload}
        case 'ADD_PLAYER':                                              // we need to another case 
          return{...state, players: [...state.players, action.payload]} we have to hit evey single player thats already in my state 
     default:                                                           and I also want to add a new one 
        return state                                                    return{...state, players: [...state.players, action.payload]}
    }                                                                   its always good to have ...state (spread operator) our state has one key with one value in this case. We would be fine with 1 spread operator but if we want to add more key and value in our state we would lose our orginal state so its always have to 2 spread operator for future but    
                                                                        we are saying players point an array has all previous player in it with this new player (action.payload)                

}












                                                        ** mapStateToProps **
mapStateToPops = {state} => {    
    return {                                ** I want to access to this particular part of the store **
        players: state.players    <--------- mapStateToProps is our way of accessing our stores values in our store as props                                 
                                            then give us access to something if we set this up we could then inside of our app
                                            component call this.props.players we have to  set up in mapStateProps as following
                                            to give us access to see what is already in our store
                                           
    }  
}



export default connect(null,{fetchPlayers})(App);
 this connect actually calling dispatch({}) for us  on the return value of fetch accounts for us. 
if we dont pass (mapStateToPops) Here nothings gonan happen. This is saying We passed this function the return value of This
is coming from our store, you can pass mapDispatch props or action creater as a second argument gives us ability to update 
our store directly from this component. so this is the formula access to this.props.fetchplayers through props to something pulled into 
 function fetchPlayers which will then update our store.  (mapStateToProps) is give us  access to what is the currently in the store 
 action (fetchPlayers) or (mapStateToPops) as a second argument gives us to ability to dispatch new action or update to our store
 directly from our component. 



App.js Phase 1 

import React from 'react';
import {connect} from 'react-redux'
import {fetchPlayers}from './actions/fetchPlayers'
class App extends React.Component {
 
  componentDidMount (){  **Our App component mounted **
   this.props.fetchPlayers({type:'FETCH_PLAYERS', payload: {name:'Checking' }})
   What is happening and knew that this return action should send to reducer 

  
   **this.props.fetchPlayers called  we passed in this action object -> ({type:'FETCH_PLAYERS', payload: {name:'Checking' }}
    then this action return this action object  how we end up hitting this debugger in our reducer ?
  What is happening and knew that this    | return action should send to the reducer(playerReducer.js) we never invoked Our                                        
   FetchPlayer.js                         | playerReducer function what did that for us?   
                                          | reducer acception action in index.js file const store = createStore(playerReducer, composeEnchancers(applyMiddleware(thunk)))
    export function fetchPlayers(action){ | telling that thats | is the rediucer is teh playerReducer but really happening                   
    return action    <--------------------|-> when its return  | that it went into  the playerReducer. What we earned that function                    
 
 that sends an action  object to  reducer. the reason its      |  expecting add once that something returned from there.                       |
 then its then fire our connect                                |
 export default connect(null,{fetchPlayers})(App);             |
dispatch to our store store.dispatch({type: 'FETCH_PLAYERS',   |   payload: {name: 'Checking'}})                                                              |
then this is therefore sent into our reducer(playerReducer.js) | as a action! you dont see dispatch because its automatically happen
playerReducer.js                                               v
export default function playerReducer(state = {players: []}, action ) {

                                                    the reason we need THUNK is when we mant to make a synchronous request 
                                                    Which is fetch request in fetch player.js            
                                                          
}
 }


  render() {
    return (
      <div className="App">
        App
      </div>
    );
  }
}

// const mapStateToProps = (state) => {
// return {
//   players: state.players
// }
// }

export default connect(null,{fetchPlayers})(App);










-----------------------------------------------------------------------------------------------------------------------------------

Part 2

Containers/PlayerContainers.js

someone to be able to creat players and then a view list of players and maybe edit players and contract 
// something that we wnt to contained with this players.

container what it should really do is render othee conponents pass them data if they require data and they also can have 
other functions inside of them callback functions or anything like that component did hope to get there unders that helps 
its more to pass it to appropriate that will render it an will handle changes thorugh a form and so on..

they typcially are a class component a lot of times they may need state is that component did about function to be which we get with
a class component. Container components are one of our top-level container components going to wonder what to render inside to our 
app component. We will render these coponents that we have (Players.js - PlayerInput.js)
Remember Capitalization does matter. Components you have to capitalized  and matching the name of the component when you have action or
reducer they are typically camel case we want to render both components inside the playerContainer so first thing you need to do 
imported connect.                   |
                                                                 |
import React from 'react';                                       |
                                                                 |
import Players from '../components/Players'   <------------------|
import PlayerInput from '../components/PlayerInput' <----------- |

class PlayerContainer extends React.Component{-> which is accessing this components from react library 
    
}

export default connect()(PlayersContainer) hen we want to use connect

we render Player container in our app.js. We remember this an application that is using redux if we want to fetch our players 
from our backend to add them in our redux store to use those players from our backend how will we use what will want to our 
players container how we gonna get  those player and how will we pass them to this players component?

Answer ; we need to import connect 

App.js 
import React from 'react';

import {connect} from 'react-redux'
*import PlayerContainer from './containers/PlayersContainer'*** we must import Player components we still our app 
                                                                 render in the Dom at index.js ****

import React from 'react';
import Players from '../components/Players'
import {connect} from 'react-redux'
import {fetchPlayers} from '../actions/fetchPlayers'
import PlayerInput from '../components/PlayerInput'


class PlayerContainer extends React.Component{
  
    componentDidMount(){
//   this.props.fetchPlayers()


    }

    render () {
      return (
      <div> 
      
        <PlayerInput/>
        <Players players={this.props.players}/> <----| we need to send  players to our players. We are sending and accessing players 
                                                     |   with  {this.props.players}
                                                     |
      </div>                                         |
                                                     |
      )                                              |
    }                                                |
                                                     |-------------------------------------------------------------------| 
}               
                                                          ****NOT***                                                   |    
 const mapStateToProps = state => { <----------  {fetchPlayers} equivalent to mapDispatchtoProps                         |
     return{                                  |   getting players for our REDUX STORE accessing them                     |
         players: state.players <-------------|-->through props inside this component then sending those players to our players component
     }                                        |    remember we set up our players.js component to receive props 
 }                                            |
                                              |
                                              |
export default connect(mapStateToProps, {fetchPlayers})(PlayerContainer)
                            

COMPONENTS 


PlayerInput.js Component
 We want to create a new form to create a new Player also our index.js shows all our Players that why we need
 playerInput component to create. In order to have controlled form you need control those values in you can have a local state 
 that controls that values, its makes simpler but you also could everytime there was a change to the form you could send that to your 
 Redux Store . its makes more sense of it as a class component that local state holding to form values. we are setting up form.
 this is what we need to create a player. 

import React from 'react'

class PlayerInput extends React.Component {

   state = {name:'',     <---------> you can set up constructor or you can set state like this 
    nationality:'', 
    bio:'',           <---------> this is what keys state neeeds
 position:'' }   
              with (event) method has know what its changing 
 handleChange = (event) => {  <------------->    without onChange method in the form nothing will change (not work)
    this.setState({                              <--------------------> this is how we update the state 
        [event.target.name]: event.target.value  <--------------------->this is how we update the state 
    })    |________________________________________________|--> since we are inside the object [event.target.name](with the bracket) is going to                                    
 } try and give our state a key of event.target.name what is [] doing first evaluating this what is in here evaluating that 
 be either name of balance [] first reads value associated with this and then sets it as a key ->  [event.target.name]:

                                                
                                                 //  name="name"onChange={this.handleChange} 
                                                 //name need to be match with key name in the state 
                                                 //we are going to be abstracting out this name value for both of these inputs 
                                                  // we want to name that we assign match our state the keys that we have in our state
 
 
 
 handleSubmit = (event) => {
    event.preventDefault()<------------------- we are saying hold on  we actually  dont want you to submit form as you nromally do
    this.props.addPlayer(this.state)           where the name, nationality, bio, position is saved in this componnet 
                                               answer state  we just want to send state  to addPlayer.js file 
                                               which is user wrote in state in above(line10/14) we are saving that information 
                                               in our state every single time someone is changing with handleChange (line16)
                                               someone changes makes a change either input we are updating that state when 
                                               they finally hit the submit button that state holds everything that user
                                               entered into the inputs so we want to send our state to addPlayer through this.props.addPlayer(this.state) 
                                               when we submit to form it goes to our database and saved then  its  updating to our Redux Store 
                                               so we are going to need to create action creator thats gonna send that data to our database. 
                                               Now we have fetchPlayers Action (fetchPlayers.js)  this is dealing with fetching all of our players from the backend   
                                               so we have to create anotehr one to deal with creating a new player 
                                               our data successfully passed in to our addPlayer
 }
                                                
   handle submit phase 2 
   
    handleSubmit = (event) => {
    event.preventDefault()                   
    this.props.addPlayer(this.state)         
   this.setState({     <---------------------------------> We can use this to clear out a form after its been submitted                                       
      name:'',         <---------------------------------> We want to reset our state back to look like empty state like above         
      height: '',
      weight: '',
      position:'',
      nationality:'',    
      points:'',
      appearance: '',
      rebound:'',
      assist:'',
      age:'',
      bonus:'',
      bio:'',                           
      image_url:'',
      youtube_url:'',
      likes:'',






   })                                       
}                                        
       
   
   
   
   
  
 }
 
 
 
 
 
 
 
 
 
 render() {                                               
     return (                                               
       <div>
     <label> Creating Player Name: </label>
     <form onSubmit={this.handleSubmit}> <------------> we are putting submit here to because we want this whole forms to submit
        <input text='text' placeholder='name' value={this.state.name} name="name"onChange={this.handleChange}/><br/><br/>
        <label> Creating nationality: </label>
        <input text='text' placeholder='nationality' value={this.state.nationality} name="balance" onChange={this.handleChange}/><br/><br/>
        <label> Creating Player bio: </label>
        <input text='text' placeholder='bio' value={this.state.bio} name="bio" onChange={this.handleChange}/><br/><br/>
        <label> Creating position: </label>
        <input text='text' placeholder='position' value={this.state.position} name="position" onChange={this.handleChange}/>
       </div>



     )

    }


}

export default PlayerInput 


addPlayer.js                                all we doing here this function is just it is written in a separate file but 
                                          we are importing it using it as a regular function we just passing data as argument  
            
export const addPlayer = (data) => {<---------initially setting up this data        
  return( dispatch) => {    |_________________|->DATA  where is that coming from ?  what is that data when we submit 
           
  }                                    
                                                          this form what data we are going to send to this addPlayer creator?  
                                                          ANSWER : his.setState on handle change everytime we change something there in 
                                                          our handle change we are updating our state(PlayerInput.js) 
                                                             handleChange = (event) => {             
                                                                         this.setState({
                                                                          [event.target.name]: event.target.value
}                                                          when we ultimately submit this form since its a controlled form our state is 
                                                           what we're gonna be sending as the argument to this add account 
                                                           DATA IS COMING FROM  state from (playerInput.js) 
                                                              state = {
                                                                  name:'',                  
                                                                  nationality:'', 
                                                                  bio:'',                           
                                                                  position:'' }   
 

                                                            why we need to send dispatch to return dispatch ?\
                                               we can import it into the input file and connect it to the action connected to the form
                                              because playerInput will be connected to our redux store. because ADDplayer component
                                              is going to be calling a function or addPlayer function that will be dispatching 
                                              something to the reducer what redux feature are we using that lets us bring  a dispatch into this action creator
                                              
                                              ANSWER thunk because of thunk we can bring dispatch the dispatch function into this 
                                              this addPlayer and dispatch call dispatch inside of here rather then having our connect 
                                               set up for us

                                              What is the reason to returning dispatch here ?
                                              answer: We have access we're returning a function in here and that 
                                              function is taking the dispatch function as an argument so that gives us access 
                                              to the dispatch function. Ther reason we are able to the do that because of thunk(Middleware)
                                              thunk is allowing us to pass in dispatch to this function that we have inside of 
                                              action creator.
                                              Okay we are passing data how are we gonna take this data to our API ?
                                              How we create a new Player ?




addPlayer.js Phase/2

export const addPlayer = (data) => {             
    
    return (dispatch) => {     
        fetch('http://localhost:3000/players', {   //post request to save to new player  it to our backend
                                                   // second argument will be object 
        headers: {                                  //<--- key that points to anothe object
        'Content-Type': 'application/json',         // <--- we are saying we are sending down to our backend going to be JSON
        'Accept':'application/json'                 // what kind of content will accepted on return on data
        },
        method : 'POST',                             // we have to tell it type of request           
        body: JSON.stringify(data)                   // body is the data we are actually sending down in this case is that Player object we are passing as data as a argument in addPlayer = (data) => { 
                                                    // we have to send server that just it accept it as a string 
                                                     // where is now its an object })
    })     
                                                    // without .then we can see immidelty changing without refresh the page 
                                                    // and we dont see it in our store when we refresh the page we re-render player container which is re-fetching players from the backend
   // we need to pull Json on the response that string going to be sent over into object notation 
    .then(response => response.json())         //<--------- so the reason we add this .then to our addPlayer is that 
                                               // we just dont want the see only this update when we update when we refresh 
                                               //we want that immidetly updated.
    .then(player => dispatch({type: 'ADD_PLAYER',payload: player}))             // we are getting the data what ever we send it to backend player controller create method        
  }                                              // and we want to dispatch this new account we just created 
}                                               // what we have to pass into the dispatch ?
                                               // ANSWER action type which we define in our reducer 


Not: The reason we wanted the add .then statment to in our addAccount We dont want only to see new player when we updated the state 
W want immediately be updated We've done now is saved our application from making an unnecessay extra fetch 
request. Its is rightaway response back and ading it to our redux store without re-fetching the data 





 PlayerList.js Component 

 we would we want for a lid that would become a list of all of our players 




   Functional Component / Players.js 

you could have choose to have this as a class component as far as the requirements are concerned you need five 
functional components so this could be a good one to use if you had five others without having something like this as a 
function component then that works to but this is absolutely works. We have to set up functional components like regular 
function personally i liek arrow function. This component will be responsible for rendering a list of players this is what wee need
and how this is component going to get those players. With calss component we just call this.props, with the functional component 
We have to pass props as an argument->  const Players = (props) => { 
We can also use destructive to pass in with the actual name ->  const Players = ({players}) => {






import React from 'react'

 const Players = (props) => { remember we set up our players component to receive props 


****we can accees anything we pass it thorugh props we dont need render inside the functional component we just need return 
functional components they are just  functions ****
return (
   <div> 
 
    Players 
 
   </div>


  )

 }

 export default Players

 summary: We are attaching app to DOM which is rendering our players container which is not rendering anything itself
 aside from these two other containers 


Phase 2 players.js 

import React from 'react'

 const Players = (props) => {
 console.log(props)
  return (
   <div>                             
                                     evertime you iterate its gonna want you put a key into the html element holding that iteration
    {props.players.map(player=> <li> key={player.id} {player.name} - {player.height}-{player.weight}-{player.position}-{player.points}</li>)}
                   we have to iterate over each player  and have a list to have return here  
                   we are creating a list with<li> list of our players on this element tags we need JSX because this is coming as 
                   JavaScript since we are inside of html element we have to access the values of these props that we are passing in 
   </div>                


  )

 }

 export default Players

 Players.js Phase3

 const Players = (props) => {
console.log(props.players[0].contracts)
  return (
   <div> 
     {props.players.map(player =>      (props.players) holding all the players in our store       
     <div key={player.id}><Player player={player}/></div>)} 
     what we ultimately are going to to want this players component to do is render links for each players rather 
     then the information about player itself
     
     #instead of players.name, player.height and attributes we just pass in our Player Component 
     so we are saying we want to render a list item for each with an player for each player and remmeber this component
     accepting props these props will have to hold a specific player what we have to pass in here.(props.players) holding all the players in our store 
     we just iterating ove all those players for each player we want to create an player component and that player component 
     must accept a player as props 
                                                            
     <Player player={player}/> we are rendering over our prop players creating an player component for each player and 
                                                                 |
                                                                 |
                                                                 |
    Player.js                                                    |
    inside that player component we are now rendering the same information we saw before our ultimate gaol is that we not going the see 
    in them a list this polayer will show all of the player information on its own page (diffrent page) so incorparated here 
    thats where our routes are going to come into play! if we want to this player component to be seen for specific player when we go to 
    some URL localhost:3001/players/1 then we are gonna have to bring in our reactor router 
    
    import React from 'react'

    const Player = (props) => {

    console.log(props)
    return (
    <li>
   {props.player.name}-{props.player.height}-{props.player.weight}-{props.player.position}-{props.player.points}-{props.player.appearance}-{props.player.rebound}-{props.player.assist}-{props.player.age}-{props.player.nationality}-{props.player.bonus}-{props.player.image_url}-{props.player.youtube_url}-{props.player.likes}-{props.player.bio}-{props.player.contracts > 0 ? props.player.contracts[0].salary: "null"} }

    </li>
)


}


export default Player 
                          
    



    
 
   </div>


  )

 }

 export default Players






















import React from 'react',



Player.js 
Player.js  where we show specific Player  information  
we just need functional component because we just displaying   we dont need anything with the state 
just receving props doesnt need to update our state directly   since we are getting props from our players container 
we will iterate over this player all we need to do pass information about that specific player 
just set regular functional component  
        
import React from 'react'
                                              ***  This is How this component accept props  ****
const Player = (props) => { <-------------- so we need to pass props as a argument when we iterate and when we rendering 
                                            a player component for each player we need to pass in props, this props that are coming in should be 
                                            a specific player  we can also  destructive like const Player = {player}) => either one 
                                            will work 
 return (
   <div>
   
   
   </div>
 )

}

Player.js Phase 2 

import React from 'react'

const Player = (props) => {

console.log(props)
return (
    <li>  / this is how we gonna render each player data(key for each player) for each player 
   {props.player.name}-{props.player.height}-{props.player.weight}-{props.player.position}-{props.player.points}-{props.player.appearance}-{props.player.rebound}-{props.player.assist}-{props.player.age}-{props.player.nationality}-{props.player.bonus}-{props.player.image_url}-{props.player.youtube_url}-{props.player.likes}-{props.player.bio}-{props.player.contracts > 0 ? props.player.contracts[0].salary: "null"} }

    </li>
)


}


export default Player 
                         
Player.js phase 3


const Player = (props) => {
const {id} = useParams()


let player = props.players[props.match.params.id - 1]<----------- pulled out speciific player that we are looking for based on 
console.log(player)                                               current path 

return (
    <li>
   Name:{player ? player.name : null} <br></br> <-------------------- we are rendering that we had to use this ternary operator 
   Height:{player ? player.height : null}<br></br>                    first time props coming through we dont have the players yet 
   Weight:{player ? player.weight : null} <br></br>                   and then after the first render we are able to access those players
   Position:{player ? player.position : null}<br></br>
   Appearance{player ? player.appearance : null} <br></br>
   Points:{player ? player.points : null}<br></br>
   Rebound{player ? player.rebound : null}<br></br>
   Assist:{player ? player.assist : null}<br></br>
   Age:{player ? player.age : null} <br></br>
   Nationality:{player ? player.nationality : null}<br></br>
   Bonus:{player ? player.bonus : null} <br></br>
   Image:{player ? player.image_url : null}<br></br>
   HighLights:{player ? player.youtube_url : null}<br></br>
   likes:{player ? player.likes : null}<br></br>
   Bio:{player ? player.bio : null}<br></br>
   contract: $ {player ? player.contracts[0].salary:null}<br></br>
   start date:  {player ? player.contracts[0].start_date:null}<br></br>
   end  date:  {player ? player.contracts[0].expiration_date:null}<br></br>
   Team Name: {player ? player.contracts[0].team_name:null}<br></br>
    </li>
)


}


export default Player 











-------------------------------------------------------------------------------------------------------------------------------------

 index.js phase 2 Routes                                       ROUTES 

We are gonna have to bring in our reactor router in.
we can a couple difrrent ways to do routes 
1- We can wrap directly in our index.js file which will give any components just like provider gives any components inside of the app access 
to setting up routes and using links like providers give us access for the store any child of components access to the store
Router does the sam ething by giving any app and any child of app access to setting up routes and using links 


ReactDOM.render(
  <Provider store={store}>
  <Router>
   <App />
   </Router> <------------ we wrapped our app in router which gives us access to the route compnent which gives us access
                          using the route componet in any child component or inside the app itself 
  </Provider>,
  
  document.getElementById('root')
);


2 - You can wrap that inside of App.js either one is fine the only diffrents if you set up in app.js app component itself does
not have route so if you set up on index.js app component will have routes. So we will set up index.js


  render() {
    return (
      <div className="App">
      <Route
        <PlayerContainer/>
        <Route
      </div>
    );
  }
}
-----------------------------------------------------------------------------------------------------------------------------------
 index js file 

import React from 'react';
import ReactDOM from 'react-dom';
import {createStore, applyMiddleware, compose} from 'redux'
import thunk from 'redux-thunk'
import { Provider } from 'react-redux'
import {BrowserRouter as Router} from 'react-router-dom'
***we are saying we use BrowserRouter and we're just gonna call it when we actually set it up we just want to call Router 
the only thing we need to import in this specific file, 'react-router-dom' we are just saying we have same features
as just plain react  router plus some additional ones its include all the react router features  when we download when we create app in the begining 


import playerReducer from './reducers/playerReducer'
import App from './App';


const composeEnchancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(playerReducer, composeEnchancers(applyMiddleware(thunk)))





ReactDOM.render(
  <Provider store={store}>
  <Router> <----- We're gonna now wrap our app component in this router component so a;; this is doing issaying app any child 
  component of app now has access to setting you can now set up routes and links inside any of those components 
  so this is definetly a good spot to get this all set up okay 
   <App />
   </Router>
  </Provider>,
  
  document.getElementById('root')
);
-------------------------------------------------------------------------------------------------------------------
App.js Phase/2 or 3 
 we are right now rendering just our players container we're  seeing everything in one page 
 what routes gonna let us do is set up routes that are associated with certain components and 
 that way when a user navigates to a specific routes they will only see the component that we set up inside our route tags

import React from 'react';
import {connect} from 'react-redux'
import PlayerContainer from './containers/PlayersContainer'
class App extends React.Component {
 
 

  render() {
    return (
      <div className="App">
        <PlayersContainer/> <--------thats mean our PlayerContainer has access to setting up routes so 
                                     inside of app all we are doing is still rendering our PlayersContainer
      </div>
    );
  }
}



export default connect()(App);

------------------------------------------------------------------------------------------------------------------------------

PlayerContainer.js Phase 1


We are setting up our routes here. The reason up our routes here instead of our app just with the way 
we are setting up PlayerInput and Players component inside here. 



<Route exact path='/players' render={() => < Players players={this.props.players}/> }
                                                 players={this.props.players}/>
                                                 Remember we set up our Players component as a 
                                                 functional component and we're passing props from our players component that we are getting 
                                                 from our store 

from here //PlayersContainer
 const mapStateToProps = state => {
     return{
         players: state.players
     }
 }

since our PlayerContainer component our players container is the one that we have right now thats connected 
to our store our app is not we did not connect it we are not fetching anything in  our app component 
in order to still give our players component access to this props (players={this.props.players}/>)
we want to set up our routes in this component. if we can move componentDidMount and mapStateToProps 
to app.js we can also do that in app.js file but since we set them up in thsi component we can set pur routes here
if we can we can move that to our app.js after




import React from 'react';
import Players from './Players'
import {connect} from 'react-redux'
import {fetchPlayers} from '../actions/fetchPlayers'
import PlayerInput from '../components/PlayerInput'
import {Route} from 'react-router-dom' we already import route in index. js so we just need import route here

class PlayerContainer extends React.Component{
  
    componentDidMount(){
  this.props.fetchPlayers()


    }

    render () {
      console.log(this.props.players)
      return (
      <div> 
       <Route path='/players/new' component={PlayerInput} />
                      |---------------------------------------> we call it what every we want but restfull we usualy routing like this  for new player in url <Route path='/players/new'
                                       |------------------------this is the component its should render when we go to component={PlayerInput} 


       <Route exact path='/players' render={() => < Players players={this.props.players}/> } />
       
       
       // our application is saying up here we're ath this path and you want me to render this component and this 
       component receiving props.render={() => < Players players={this.props.players}/> } /renders takes in a function wheras this
       just point it to a component or render is going to take in a function 
      when you use render and when you want to pass in props to through a route the actual component in here is going to look just as it did as if 
      if you were rendering it outside here you still going to pass in props and its just inside of this render  
      
      exact path='/players' 
      exact we added exact keyword we are saying only show this component if the path exactly matches this /players
      
      
      
      </div>

      )
    }

}

 const mapStateToProps = state => {
     return{
         players: state.players
     }
 }


export default connect(mapStateToProps, {fetchPlayers})(PlayerContainer)



PlayerContainer.js Phase 2

import React from 'react';
import Players from './Players'
import {connect} from 'react-redux'
import {fetchPlayers} from '../actions/fetchPlayers'
import PlayerInput from '../components/PlayerInput'
import Player from '../components/Player'
import {Route} from 'react-router-dom'

class PlayerContainer extends React.Component{
  
    componentDidMount(){
  this.props.fetchPlayers()


    }

    render () {
      console.log(this.props.players)
      return (
      <div> 
       <Route path='/players/new' component={PlayerInput} /><--- Accounts container now  instead of rendering directly 
                                   |------------------|      our player input in our players components hold our routes----|
      ourPlayerInput we're just rendering with this components whereas our player in our players                           |
              we are using render |    |   we are passing in not only routes props but also these all of these players     |
              that are coming from our redux Store                                                                         |
       <Route path='/players/:id' render={(routerProps) => < Player {...routerProps} players={this.props.players}/> }/>    |
       <Route exact path='/players' render={(routerProps) => < Players {...routerProps} players={this.props.players}/> }/> |
                                                              |-------|----------------------------------------------------|
      
      </div>

      )
    }

}

 const mapStateToProps = state => {
     return{
         players: state.players
     }
 }


export default connect(mapStateToProps, {fetchPlayers})(PlayerContainer)